/* eslint-env node */
import { resolveBearerAuthorization } from '../_shared/http.js';
import { createSupabaseAdminClient, readSupabaseAdminConfig } from '../_shared/supabase-admin.js';
import {
  ensureMembership,
  readEnv,
  respond,
  resolveOrgId,
  resolveTenantPublicClient,
  parseRequestBody,
} from '../_shared/org-bff.js';

function classifyTenantDbError(error, { resource, operation } = {}) {
  const message = typeof error?.message === 'string' ? error.message : null;
  const code = typeof error?.code === 'string' ? error.code : null;
  const details = typeof error?.details === 'string' ? error.details : null;
  const hint = typeof error?.hint === 'string' ? error.hint : null;
  const status = typeof error?.status === 'number' ? error.status : (typeof error?.statusCode === 'number' ? error.statusCode : null);

  if (code === 'PGRST301') {
    return {
      status: 428,
      body: {
        error: 'invalid_tenant_dedicated_key',
        message: 'Tenant API rejected the dedicated key. Ensure the stored dedicated key is the tenant app_user JWT generated by the tenant setup SQL SSOT (final SELECT output), and that org_settings.anon_key matches the tenant anon key.',
        details: {
          resource: resource || null,
          operation: operation || null,
          code,
          message,
          details,
          hint,
        },
      },
    };
  }

  if (status === 401) {
    return {
      status: 428,
      body: {
        error: 'invalid_tenant_dedicated_key',
        message: 'Tenant API returned 401. This usually means the dedicated app_user JWT is not signed with the tenant project JWT secret (or org_settings.anon_key is wrong). Re-generate the APP_DEDICATED_KEY from the tenant setup SQL SSOT final SELECT and re-save it.',
        details: {
          resource: resource || null,
          operation: operation || null,
          status,
          code,
          message,
          details,
          hint,
        },
      },
    };
  }

  const text = `${code || ''} ${message || ''} ${details || ''}`.toLowerCase();
  const looksLikeMissingTable =
    code === '42P01' ||
    code === 'PGRST205' ||
    text.includes('schema cache') ||
    text.includes('does not exist') ||
    text.includes('could not find the table');

  const looksLikeMissingRelationship =
    text.includes('relationship') && (text.includes('could not find') || text.includes('no relationship'));

  if (looksLikeMissingTable || looksLikeMissingRelationship) {
    return {
      status: 424,
      body: {
        error: 'schema_upgrade_required',
        message: 'Tenant scheduling schema is missing or incomplete.',
        details: {
          resource: resource || null,
          operation: operation || null,
          code,
          message,
          details,
          hint,
        },
      },
    };
  }

  return {
    status: 500,
    body: {
      error: 'database_error',
      message: message || 'Tenant database query failed.',
      details: {
        resource: resource || null,
        operation: operation || null,
        code,
        details,
        hint,
      },
    },
  };
}

async function handleGet(context, tenantClient, req) {
  const { startDate, endDate } = req.query;

  if (!startDate || !endDate) {
    return respond(context, 400, { error: 'missing_date_range' });
  }

  const { data: instances, error } = await tenantClient
    .from('lesson_instances')
    .select('*')
    .gte('datetime_start', startDate)
    .lte('datetime_start', endDate)
    .order('datetime_start');

  if (error) {
    context.log.error('Failed to fetch lesson instances', error);
    const classified = classifyTenantDbError(error, { resource: 'lesson_instances', operation: 'select' });
    return respond(context, classified.status, classified.body);
  }

  const instanceIds = Array.isArray(instances) ? instances.map((row) => row?.id).filter(Boolean) : [];
  if (instanceIds.length === 0) {
    return respond(context, 200, { data: [] });
  }

  const { data: participants, error: participantsError } = await tenantClient
    .from('lesson_participants')
    .select('*')
    .in('lesson_instance_id', instanceIds);

  if (participantsError) {
    context.log.error('Failed to fetch lesson participants', participantsError);
    const classified = classifyTenantDbError(participantsError, { resource: 'lesson_participants', operation: 'select' });
    // Degrade gracefully: return instances without participants, but include warning details.
    return respond(context, 200, {
      data: instances.map((row) => ({ ...row, lesson_participants: [] })),
      warning: classified.body,
    });
  }

  const byInstanceId = new Map();
  for (const participant of Array.isArray(participants) ? participants : []) {
    const key = participant?.lesson_instance_id;
    if (!key) continue;
    const bucket = byInstanceId.get(key) || [];
    bucket.push(participant);
    byInstanceId.set(key, bucket);
  }

  const result = instances.map((row) => ({
    ...row,
    lesson_participants: byInstanceId.get(row.id) || [],
  }));

  return respond(context, 200, { data: result });
}

async function handlePost(context, tenantClient, req) {
  const body = parseRequestBody(req);
  const { participants, ...instanceData } = body;

  if (!instanceData.datetime_start || !instanceData.instructor_employee_id || !instanceData.service_id) {
    return respond(context, 400, { error: 'missing_required_fields' });
  }

  // Insert instance
  const { data: instance, error: instanceError } = await tenantClient
    .from('lesson_instances')
    .insert(instanceData)
    .select()
    .single();

  if (instanceError) {
    context.log.error('Failed to create lesson instance', instanceError);
    const classified = classifyTenantDbError(instanceError, { resource: 'lesson_instances', operation: 'insert' });
    return respond(context, classified.status, { ...classified.body, error: 'database_error_instance' });
  }

  // Insert participants if any
  if (participants && Array.isArray(participants) && participants.length > 0) {
    const participantsData = participants.map(p => ({
      ...p,
      lesson_instance_id: instance.id
    }));

    const { error: participantsError } = await tenantClient
      .from('lesson_participants')
      .insert(participantsData);

    if (participantsError) {
      context.log.error('Failed to create lesson participants', participantsError);
      // Note: In a real production scenario, we might want to rollback the instance creation here
      // or use a stored procedure for atomicity.
      const classified = classifyTenantDbError(participantsError, { resource: 'lesson_participants', operation: 'insert' });
      return respond(context, classified.status, {
        ...classified.body,
        error: 'database_error_participants',
        instanceId: instance.id,
      });
    }
  }

  // Fetch complete object to return (manual join to avoid FK relationship dependency)
  const { data: freshInstance, error: fetchError } = await tenantClient
    .from('lesson_instances')
    .select('*')
    .eq('id', instance.id)
    .maybeSingle();

  if (fetchError || !freshInstance) {
    return respond(context, 201, { data: { ...instance, lesson_participants: [] }, warning: 'failed_to_fetch_complete_object' });
  }

  const { data: freshParticipants, error: participantsFetchError } = await tenantClient
    .from('lesson_participants')
    .select('*')
    .eq('lesson_instance_id', instance.id);

  if (participantsFetchError) {
    return respond(context, 201, { data: { ...freshInstance, lesson_participants: [] }, warning: 'failed_to_fetch_participants' });
  }

  return respond(context, 201, { data: { ...freshInstance, lesson_participants: freshParticipants || [] } });
}

async function handlePut(context, tenantClient, req) {
  const body = parseRequestBody(req);
  const { id, ...updates } = body;

  if (!id) {
    return respond(context, 400, { error: 'missing_id' });
  }

  const { data, error } = await tenantClient
    .from('lesson_instances')
    .update(updates)
    .eq('id', id)
    .select()
    .single();

  if (error) {
    context.log.error('Failed to update lesson instance', error);
    const classified = classifyTenantDbError(error, { resource: 'lesson_instances', operation: 'update' });
    return respond(context, classified.status, classified.body);
  }

  return respond(context, 200, { data });
}

export default async function (context, req) {
  const env = readEnv(context);
  const adminConfig = readSupabaseAdminConfig(env);
  const supabase = createSupabaseAdminClient(adminConfig);

  const authorization = resolveBearerAuthorization(req);
  const orgId = resolveOrgId(req);

  if (!authorization?.token) {
    return respond(context, 401, { error: 'missing_auth' });
  }

  if (!orgId) {
    return respond(context, 400, { error: 'missing_org_id' });
  }

  const authResult = await supabase.auth.getUser(authorization.token);
  if (authResult.error || !authResult.data?.user?.id) {
    return respond(context, 401, { error: 'invalid_token' });
  }

  const userId = authResult.data.user.id;

  const membership = await ensureMembership(supabase, orgId, userId);
  if (!membership) {
    return respond(context, 403, { error: 'forbidden' });
  }

  const { client: tenantClient, error: tenantError } = await resolveTenantPublicClient(context, supabase, env, orgId);
  if (tenantError) {
    return respond(context, tenantError.status, tenantError.body);
  }

  switch (req.method.toLowerCase()) {
    case 'get':
      return handleGet(context, tenantClient, req);
    case 'post':
      return handlePost(context, tenantClient, req);
    case 'put':
      return handlePut(context, tenantClient, req);
    default:
      return respond(context, 405, { error: 'method_not_allowed' });
  }
}
